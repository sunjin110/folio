/*
folio

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// LanguageCode the model 'LanguageCode'
type LanguageCode string

// List of language_code
const (
	AUTO LanguageCode = "auto"
	AF LanguageCode = "af"
	SQ LanguageCode = "sq"
	AM LanguageCode = "am"
	AR LanguageCode = "ar"
	HY LanguageCode = "hy"
	AZ LanguageCode = "az"
	BN LanguageCode = "bn"
	BS LanguageCode = "bs"
	BG LanguageCode = "bg"
	CA LanguageCode = "ca"
	ZH LanguageCode = "zh"
	ZH_TW LanguageCode = "zh-TW"
	HR LanguageCode = "hr"
	CS LanguageCode = "cs"
	DA LanguageCode = "da"
	FA_AF LanguageCode = "fa-AF"
	NL LanguageCode = "nl"
	EN LanguageCode = "en"
	ET LanguageCode = "et"
	FA LanguageCode = "fa"
	TL LanguageCode = "tl"
	FI LanguageCode = "fi"
	FR LanguageCode = "fr"
	FR_CA LanguageCode = "fr-CA"
	KA LanguageCode = "ka"
	DE LanguageCode = "de"
	EL LanguageCode = "el"
	GU LanguageCode = "gu"
	HT LanguageCode = "ht"
	HA LanguageCode = "ha"
	HE LanguageCode = "he"
	HI LanguageCode = "hi"
	HU LanguageCode = "hu"
	IS LanguageCode = "is"
	ID LanguageCode = "id"
	GA LanguageCode = "ga"
	IT LanguageCode = "it"
	JA LanguageCode = "ja"
	KN LanguageCode = "kn"
	KK LanguageCode = "kk"
	KO LanguageCode = "ko"
	LV LanguageCode = "lv"
	LT LanguageCode = "lt"
	MK LanguageCode = "mk"
	MS LanguageCode = "ms"
	ML LanguageCode = "ml"
	MT LanguageCode = "mt"
	MR LanguageCode = "mr"
	MN LanguageCode = "mn"
	NO LanguageCode = "no"
	PS LanguageCode = "ps"
	PL LanguageCode = "pl"
	PT LanguageCode = "pt"
	PT_PT LanguageCode = "pt-PT"
	PA LanguageCode = "pa"
	RO LanguageCode = "ro"
	RU LanguageCode = "ru"
	SR LanguageCode = "sr"
	SI LanguageCode = "si"
	SK LanguageCode = "sk"
	SL LanguageCode = "sl"
	SO LanguageCode = "so"
	ES LanguageCode = "es"
	ES_MX LanguageCode = "es-MX"
	SW LanguageCode = "sw"
	SV LanguageCode = "sv"
	TA LanguageCode = "ta"
	TE LanguageCode = "te"
	TH LanguageCode = "th"
	TR LanguageCode = "tr"
	UK LanguageCode = "uk"
	UR LanguageCode = "ur"
	UZ LanguageCode = "uz"
	VI LanguageCode = "vi"
	CY LanguageCode = "cy"
)

// All allowed values of LanguageCode enum
var AllowedLanguageCodeEnumValues = []LanguageCode{
	"auto",
	"af",
	"sq",
	"am",
	"ar",
	"hy",
	"az",
	"bn",
	"bs",
	"bg",
	"ca",
	"zh",
	"zh-TW",
	"hr",
	"cs",
	"da",
	"fa-AF",
	"nl",
	"en",
	"et",
	"fa",
	"tl",
	"fi",
	"fr",
	"fr-CA",
	"ka",
	"de",
	"el",
	"gu",
	"ht",
	"ha",
	"he",
	"hi",
	"hu",
	"is",
	"id",
	"ga",
	"it",
	"ja",
	"kn",
	"kk",
	"ko",
	"lv",
	"lt",
	"mk",
	"ms",
	"ml",
	"mt",
	"mr",
	"mn",
	"no",
	"ps",
	"pl",
	"pt",
	"pt-PT",
	"pa",
	"ro",
	"ru",
	"sr",
	"si",
	"sk",
	"sl",
	"so",
	"es",
	"es-MX",
	"sw",
	"sv",
	"ta",
	"te",
	"th",
	"tr",
	"uk",
	"ur",
	"uz",
	"vi",
	"cy",
}

func (v *LanguageCode) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := LanguageCode(value)
	for _, existing := range AllowedLanguageCodeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid LanguageCode", value)
}

// NewLanguageCodeFromValue returns a pointer to a valid LanguageCode
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewLanguageCodeFromValue(v string) (*LanguageCode, error) {
	ev := LanguageCode(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for LanguageCode: valid values are %v", v, AllowedLanguageCodeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v LanguageCode) IsValid() bool {
	for _, existing := range AllowedLanguageCodeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to language_code value
func (v LanguageCode) Ptr() *LanguageCode {
	return &v
}

type NullableLanguageCode struct {
	value *LanguageCode
	isSet bool
}

func (v NullableLanguageCode) Get() *LanguageCode {
	return v.value
}

func (v *NullableLanguageCode) Set(val *LanguageCode) {
	v.value = val
	v.isSet = true
}

func (v NullableLanguageCode) IsSet() bool {
	return v.isSet
}

func (v *NullableLanguageCode) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLanguageCode(val *LanguageCode) *NullableLanguageCode {
	return &NullableLanguageCode{value: val, isSet: true}
}

func (v NullableLanguageCode) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLanguageCode) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

